---
layout: post
title: Paging through results on google app engine
categories:
- appengine
- paging
- coding
---

The sample code given on the appengine article about paging through results is incomplete for the method of paging through a results set by item key. Here is an example that will page forward and backward through a result set by item key. This example will display items oldest first. The next link will bring you to the set of next newest items.<br /><br /><h5>template code for displaying the results, let's say it's called listitems.html</h5><br /><pre class="brush: html"> <br />    {% if previous %}<br />      <p><a href="?previous={{ previous }}">previous</a></p>        <br />    {% endif %}<br />    {% if next %}<br />      <p><a href="?next={{ next }}">next</a></p>        <br />    {% endif %}<br />  <br />   {% for item in items %}<br />     item<br />  {% endfor %}<br /></pre><br /><br /><h5><br />the relevant code in your application file.</h5><br /><pre class="brush: python"> <br />#assume you have imported all of the googley goodness<br /><br />#this sets the paging size<br />FETCHLIMIT = 10<br /><br /># an empty class for testing against.<br />class Item(db.Model):<br />    created = db.DateTimeProperty(auto_now_add=True)<br /><br />class ListItems(webapp.RequestHandler):<br />    def get(self):<br />        query = Item.all()<br />        items = query.fetch(FETCHLIMIT+1)<br />        <br />        forward = self.request.get("next")<br />        back = self.request.get("previous")<br /><br />        if forward:<br />            items = Item.all().order("__key__").filter('__key__ >=', db.Key(forward)).fetch(FETCHLIMIT+1)<br />        elif back:<br />            items = Item.all().order("-__key__").filter('__key__ <=', db.Key(back)).fetch(FETCHLIMIT+1)<br />            items.reverse()<br />            # in order to go backwards through the set we need to revers the order so that we get the newest keys on top<br />            # the filter than drops the items we have already seen<br />            # but to get the previous link to pass the oldest key in the set we need to reverse the items before heading on<br />        else:<br />            items = Item.all().order("__key__").fetch(FETCHLIMIT+1)     <br />       # the key part here missing from the example code is making the right call against the right passed variable<br />       # forward = self.request.get("next") returns a string, we convert that to a key object with the line:<br />       # db.Key(forward)<br />             <br />        # do we show next and previous links?<br />        # start with none<br />        next = None<br />        previous = None <br />        # we need to get the key of the very first item in the results set, <br />        query = Item.all()<br />        first_item_key = query.fetch(1)[0].key()<br />        previous = activities[0].key()<br />        # if previous key is the same as the key of the first item in the class then don't display a previous link<br />        if previous == first_item_key: previous = None <br /><br />        # we have just asked for a batch of items. if the returned set is bigger than the amount we want on a page<br />        # we know there are some results left to get so we set a next link<br />        if len(items) == FETCHLIMIT+1:<br />            next = items[-1].key()<br />            items = items[:FETCHLIMIT]<br />        <br />        # perhaps we want to display the total count of objects in the datastore<br />        item_number = Item.all().count()<br />        template_values = {'count':item_number, 'items':items, 'next':next, 'previous':previous}<br />        path = os.path.join(os.path.dirname(__file__), 'listitems.html')<br />        self.response.out.write(template.render(path, template_values))<br /></pre>
